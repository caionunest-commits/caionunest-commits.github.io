 <!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Blog de Atividades em Python</title>

    <style>
        body {
            font-family: Arial, sans-serif;
            background: #f4f4f4;
            margin: 0;
            padding: 0;
        }

        header {
            background: #222;
            color: white;
            padding: 20px;
            text-align: center;
        }

        h1 { margin: 0; }

        .container {
            width: 80%;
            margin: auto;
            padding: 20px;
        }

        .post {
            background: white;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 0 5px #00000030;
        }

        .post h2 {
            margin-top: 0;
        }

        pre {
            background: #272822;
            color: #f8f8f2;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
        }

        footer {
            background: #222;
            color: white;
            padding: 10px;
            text-align: center;
            margin-top: 20px;
        }
    </style>
</head>

<body>

<header>
    <h1>Blog de Atividades em Python</h1>
    <p>Projeto para entrega escolar</p>
</header>

<div class="container">

    <!-- EXEMPLO DE POSTAGEM 1 -->
    <div class="post">
        <h2>Atividade 1 —  Atividade: Cotação do Dólar – Março de 2016 </h2>
        <p>Código atividade.</p>

        <pre><code>



import calendar             
from datetime import datetime
import requests              
import pandas as pd          
import plotly.express as px  


def gerar_grafico_dolar_marco_2016():
    # ------------------------------------------------------------
    # 1. Definindo o mês e o ano que eu quero analisar
    # ------------------------------------------------------------
    # O professor pediu pra usar o formato "MMYYYY".
    # No meu caso: 03 (março) e 2016.
    mmYYYY = "032016"

    # Aqui eu transformo essa string em uma data de verdade.
    # "%m%Y" significa: mês com 2 dígitos + ano com 4 dígitos.
    # Isso vai virar 01/03/2016 automaticamente.
    first_date = datetime.strptime(mmYYYY, "%m%Y")

    # Agora eu preciso saber qual é o último dia de março de 2016.
    last_day = calendar.monthrange(first_date.year, first_date.month)[1]

    # Aqui eu pego a primeira data (01/03/2016) e só troco o "dia"
    # para o último dia do mês (31).
    last_date = first_date.replace(day=last_day)

    # A API do Banco Central só aceita data formato americano

    data_inicial_str = first_date.strftime("%m-%d-%Y")
    data_final_str = last_date.strftime("%m-%d-%Y")

    # ------------------------------------------------------------
    # 2. Montando a URL da API do Banco Central (PTAX)
    # ------------------------------------------------------------
    # "CotacaoDolarPeriodo", que recebe data inicial e final.
    base_url = "https://olinda.bcb.gov.br/olinda/servico/PTAX/versao/v1/odata/"
    endpoint = "CotacaoDolarPeriodo(dataInicial=@dataInicial,dataFinalCotacao=@dataFinalCotacao)"

    # Aqui eu monto a "query string", que são os parâmetros que vão
    # depois da interrogação na URL. Basicamente estou falando:
    # - qual o intervalo de datas
    # - que eu quero o resultado em JSON
    # - e que colunas eu quero pegar da resposta.
    params = (
        f"@dataInicial='{data_inicial_str}'&"
        f"@dataFinalCotacao='{data_final_str}'&"
        "$top=1000&$format=json&"
        "$select=cotacaoCompra,cotacaoVenda,dataHoraCotacao"
    )

    # Junto tudo pra virar uma URL completa.
    url = base_url + endpoint + "?" + params

    # ------------------------------------------------------------
    # 3. Chamando a API de verdade
    # ------------------------------------------------------------
    # Aqui eu realmente mando a requisição pro servidor do Banco Central.
    response = requests.get(url)

    # Se der algum erro (tipo URL errada, servidor fora do ar, etc.),
    # essa linha abaixo já estoura um erro pra eu perceber.
    response.raise_for_status()

    # O retorno vem em formato JSON. Dentro dele existe uma chave
    # chamada "value" que é onde estão os dados que eu quero.
    dados = response.json()["value"]

    # Se por algum motivo não vier nada, eu já aviso.
    if not dados:
        raise ValueError("Nenhum dado retornado pela API para março de 2016.")

    # ------------------------------------------------------------
    # 4. Jogando os dados pra um DataFrame (tabela) do pandas
    # ------------------------------------------------------------
    # Transformo a lista de dicionários em uma tabela, que é bem
    # mais fácil de mexer.
    df = pd.DataFrame(dados)

    # A coluna "dataHoraCotacao" está como texto. Aqui eu transformo
    # em data/hora de verdade, pra conseguir filtrar, ordenar, etc.
    df["dataHoraCotacao"] = pd.to_datetime(df["dataHoraCotacao"])

    # Crio uma coluna só com a data (sem o horário), porque no final
    # eu quero uma linha por dia, não por horário.
    df["data"] = df["dataHoraCotacao"].dt.date

    # Pode acontecer de ter mais de uma cotação no mesmo dia,
    # em horários diferentes. Pra simplificar, escolhi pegar
    # a última cotação do dia.
    df = (
        df.sort_values("dataHoraCotacao")                # ordeno pela hora
          .groupby("data")                               # agrupo por dia
          .agg({
              "cotacaoCompra": "last",                   # pego a última compra
              "cotacaoVenda": "last"                     # e a última venda
          })
          .reset_index()
    )

    # ------------------------------------------------------------
    # 5. Lidando com finais de semana e feriados
    # ------------------------------------------------------------
    # O enunciado fala que, se não tiver cotação num dia (por ser
    # fim de semana ou feriado), eu devo usar o valor do dia útil
    # anterior. 

    # Primeiro, crio um intervalo de datas contínuo:
    datas_completas = pd.date_range(
        start=first_date.date(),
        end=last_date.date(),
        freq="D"   # D = diário (todo dia)
    )

    # Coloco essas datas em um DataFrame, só com uma coluna "data".
    df_completo = pd.DataFrame({"data": datas_completas})

    # Agora faço um "merge" entre:
    # - df_completo: todas as datas de março
    # - df: só os dias que têm cotação
    #
    # how="left" garante que nenhuma data de df_completo será perdida.
    df_merged = df_completo.merge(df, on="data", how="left")

    # Depois do merge, os dias sem cotação vão ficar com NaN nas
    # colunas de compra e venda. Aqui eu faço o famoso "ffill"
    # (forward fill), que basicamente copia o último valor válido
    # pra frente.
    df_merged[["cotacaoCompra", "cotacaoVenda"]] = (
        df_merged[["cotacaoCompra", "cotacaoVenda"]].fillna(method="ffill")
    )

    # Pode acontecer do primeiro dia do mês ainda ficar vazio
    # (por exemplo, se começar com feriado). Nesse caso eu uso o
    # "bfill" (backward fill), que faz o contrário: pega o primeiro
    # valor que aparece depois e preenche pra trás.
    df_merged[["cotacaoCompra", "cotacaoVenda"]] = (
        df_merged[["cotacaoCompra", "cotacaoVenda"]].fillna(method="bfill")
    )

    # ------------------------------------------------------------
    # 6. Finalmente, gerando o gráfico com Plotly
    # ------------------------------------------------------------
    # Agora que eu tenho uma série certinha, com um valor por dia,
    # dá pra plotar e ver visualmente como o dólar se comportou
    # ao longo de março de 2016.
    fig = px.line(
        df_merged,
        x="data",                                  # eixo X: datas
        y=["cotacaoCompra", "cotacaoVenda"],      # eixo Y: duas linhas (compra e venda)
        title="Cotação do Dólar - Março de 2016",
        labels={
            "value": "Cotação em R$",
            "data": "Data",
            "variable": "Tipo de cotação"
        },
    )

    # Só deixando o gráfico um pouco mais organizado:
    fig.update_layout(
        xaxis_title="Data",
        yaxis_title="Cotação do dólar (R$)",
        legend_title="",          # legenda sem título
        hovermode="x unified"     # quando passa o mouse, mostra compra e venda juntos
    )

    # Mostra o gráfico na tela.
    fig.show()

    # Retorno o DataFrame final caso eu queira olhar os números
    # em forma de tabela depois.
    return df_merged


# ------------------------------------------------------------
# 7. Rodando o código
# ------------------------------------------------------------
# Se eu executar esse arquivo direto,
# essa parte aqui embaixo é que vai rodar, chamando a função que
# monta tudo e mostra o gráfico.
if __name__ == "__main__":
    gerar_grafico_dolar_marco_2016()
        </code></pre>
    </div>

    <div class="post">
        <h2>Atividade 2 </h2>
        <p>Api onibus</p>

        <pre><code>
import os
import requests
from dotenv import load_dotenv
import folium

# Carrega as variáveis de ambiente do arquivo sptrans.env
load_dotenv("sptrans.env")
SPTRANS_TOKEN = os.getenv("SPTRANS_TOKEN")

# Verifica se o token foi carregado corretamente
if not SPTRANS_TOKEN:
    raise ValueError("Token SPTRANS_TOKEN não encontrado em sptrans.env")

# URL base da API Olho Vivo da SPTrans
BASE_URL = "http://api.olhovivo.sptrans.com.br/v2.1"


def autenticar():
    # Cria uma sessão HTTP para manter a autenticação
    s = requests.Session()
    # Faz o POST na rota de autenticação usando o token
    res = s.post(f"{BASE_URL}/Login/Autenticar?token={SPTRANS_TOKEN}")
    # Confere se a API retornou "true" (autenticado)
    if res.text.lower() != "true":
        raise RuntimeError(f"Falha na autenticação: {res.text}")
    print("Autenticação OK.")
    # Retorna a sessão já autenticada para reutilizar nas próximas requisições
    return s


def buscar_linha_148L(sessao):
    # Busca as linhas que combinem com o termo "148L"
    res = sessao.get(f"{BASE_URL}/Linha/Buscar?termosBusca=148L")
    linhas = res.json()

    # Se não vier nenhuma linha, dispara erro
    if not linhas:
        raise RuntimeError("Nenhuma linha encontrada para o termo 148L")

    # Mostra no console as linhas retornadas para conferência
    print("Linhas retornadas para '148L':")
    for l in linhas:
        print(l)

    linha_escolhida = None
    # Tenta selecionar especificamente a linha cujo código curto (lt) é "148L"
    for l in linhas:
        if l.get("lt") == "148L":
            linha_escolhida = l
            break

    # Se não achar exatamente "148L", pega a primeira da lista mesmo
    if linha_escolhida is None:
        linha_escolhida = linhas[0]

    print("\nLinha selecionada:")
    print(linha_escolhida)

    # Retorna o código da linha (cl) e o dicionário completo da linha
    return linha_escolhida["cl"], linha_escolhida


def buscar_paradas_por_linha(sessao, codigo_linha):
    # Monta a URL para buscar as paradas associadas à linha
    url = f"{BASE_URL}/Parada/BuscarParadasPorLinha?codigoLinha={codigo_linha}"
    res = sessao.get(url)
    paradas = res.json()

    # Mostra a quantidade de paradas retornadas
    print(f"Quantidade de paradas encontradas: {len(paradas)}")

    # Se não vier nenhuma parada, gera erro
    if not paradas:
        raise RuntimeError(f"Nenhuma parada encontrada para a linha código {codigo_linha}.")

    # Retorna a lista de paradas (cada parada é um dicionário com dados da API)
    return paradas


def gerar_mapa_paradas(paradas, nome_linha, arquivo_saida="mapa_paradas_148L.html"):
    # Calcula a latitude e longitude médias para centralizar o mapa
    med_lat = sum(p["py"] for p in paradas) / len(paradas)
    med_lon = sum(p["px"] for p in paradas) / len(paradas)

    # Cria o mapa centrado na média das coordenadas das paradas
    m = folium.Map(location=[med_lat, med_lon], zoom_start=14)

    # Percorre cada parada e adiciona um marcador no mapa
    for p in paradas:
        lat = p["py"]
        lon = p["px"]
        nome = p.get("np", "Parada sem nome")  # nome da parada
        endereco = p.get("ed", "")            # endereço da parada

        # Texto que aparece no popup quando clica no marcador
        popup_text = f"{nome}<br>{endereco}"

        # Cria o marcador azul com ícone de informação
        folium.Marker(
            location=[lat, lon],
            popup=popup_text,
            icon=folium.Icon(color="blue", icon="info-sign")
        ).add_to(m)

    # Salva o mapa como um arquivo HTML
    m.save(arquivo_saida)
    print(f"Mapa de paradas salvo em: {arquivo_saida}")


def main():
    # Autentica na API e obtém a sessão
    sessao = autenticar()

    # Busca a linha 148L e pega o código interno dela
    codigo_linha, dados_linha = buscar_linha_148L(sessao)

    # Monta uma string com o nome da linha, tipo e sentido
    nome_linha = f"{dados_linha.get('lt', '')} - {dados_linha.get('tp', '')} / {dados_linha.get('ts', '')}"

    # Busca todas as paradas associadas a essa linha
    paradas = buscar_paradas_por_linha(sessao, codigo_linha)

    # Gera o mapa com todas as paradas dessa linha
    gerar_mapa_paradas(paradas, nome_linha)


# Ponto de entrada do script: só roda main() se o arquivo for executado diretamente
if __name__ == "__main__":
    main()
        </code></pre>
    </div>

</div>

    <div class="post">
        <h2>Atividade 3</h2>
        <p>Regressão Linear.</p>

        <pre><code>
import numpy as np
import pandas as pd
from plotnine import (
    ggplot, aes, geom_point, geom_abline, theme, element_text, ggsave
)

# Importo as bibliotecas necessárias

valores_x = np.loadtxt("X.txt")
valores_y = np.loadtxt("y.txt")

# Carrego os dados de x e y dos arquivos de texto

X = valores_x.reshape(-1, 1)
y = valores_y.reshape(-1, 1)

# Ajusto os vetores para formato de coluna (matriz n x 1)

ones = np.ones((X.shape[0], 1))
X_design = np.hstack([ones, X])

# Crio a matriz de projeto da regressão: primeira coluna de 1s e segunda com x

XT = X_design.T
XTX = XT @ X_design
XTX_inv = np.linalg.inv(XTX)
XTy = XT @ y
beta = XTX_inv @ XTy

# Calculo os coeficientes da regressão linear usando a fórmula matricial

a = float(beta[0, 0])
b = float(beta[1, 0])

# Separo o intercepto (a) e a inclinação (b) da reta

df = pd.DataFrame({
    "x": valores_x,
    "y": valores_y
})

# Coloco os dados em um DataFrame para facilitar o uso no gráfico

plot = (
    ggplot(df, aes("x", "y"))
    + geom_point(color="blue", size=2)              # pontos observados
    + geom_abline(intercept=a, slope=b, color="red")  # reta de regressão
    + theme(
        figure_size=(6, 4),
        axis_title_x=element_text(size=12),
        axis_title_y=element_text(size=12),
        title=element_text(size=14, weight="bold")
    )
)

# Crio o gráfico com os pontos e a reta ajustada

ggsave(plot, "grafico_regressao.png", dpi=300)

# Salvo o gráfico em um arquivo PNG

plot
# Exibo o gráfico
        </code></pre>
    </div>

</div>
<footer>
    © 2025 — Blog de Atividades em Python
</footer>

</body>
</html>
